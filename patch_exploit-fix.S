//
// Copyright (c) 2020-2023 Leseratte10
// This file is part of the Priiloader Wiimmfi patch hack by Leseratte.
// https://github.com/Leseratte10/priiloader-patch-wiimmfi
// 
//
// IOS36, which MKWii uses by default, is a pretty old IOS that has a 
// couple of security issues. Since MKWii runs just fine on newer IOSes,
// this code checks to see if IOS58 is installed, and if it is, it runs
// Mario Kart Wii with that IOS. If it's not present, it uses IOS36 as before.
//
//


#if VERSION != 0
.int FUNCTIONCALL
.int PATCHADDR + 4
.int 0
.int 0

#else
/// PARAMETERS:
.globl _loading
// "loading" is the very first function that runs. and needs to be on top of the file. stores stack crap, then calls main
_loading:
	// store stack stuff:
	stwu r1, -172(r1);
	stw r0,8(r1)
	mflr r0
	stw r0,176(r1)
	stmw r2,20(r1)

	// at this point we would call OSDisableInterrupts. that function
	// just has 4 lines (+blr), let's just include it in here, then
	// we don't have to bother about porting it to all the different regions
	mfmsr r3; 
	rlwinm r4, r3, 0x0, 0x11, 0xf; 
	mtmsr r4; 
	rlwinm r3, r3, 0x11, 0x1f, 0x1f; 
	
	stw r3, 12(r1); 	// store current interrupts
	
	// All the setup is done. Stack is stored, interrupts are saved. 
	// Fall through into the code

	code:
		
    // At this point the game is loaded (but not yet Wiimmfi patched)
    // check the game ID: 
        
    lis r27, 0x8000; 
    li r4, 0x52; 	// 'R'
    li r5, 0x4d; 	// 'M'
    li r6, 0x43; 	// 'C'

    lbz r7, 0(r27);
    cmpw r7, r4;
    bne- 5f;

    lbz r7, 1(r27);
    cmpw r7, r5;
    bne+ 5f;

    lbz r7, 2(r27);
    cmpw r7, r6;
    bne- 5f;
        
        
    // Apparently this is MKWii, so let's start patching.
    
    // lets check if 00000001-0000003a (IOS58) is present
    li r3, 1;   // 00000001
    li r4, 58;  // 0000003a     
    li r5, 0; 
    lis r15, PARAMS@ha; 
    addi r15, r15, PARAMS@l; 
    addi r6, r15, 8; 
	mr r16, r6;
    
	lwz r17, 0(r15);
    mtlr r17;
    blrl
    
    // Now we called the function. let's check the return val. 
    cmpwi r3, 0; 
    bne- 5f;        // looks like the function failed. probably IOS58 doesn't exist. 
    
    lwz r16, 0(r16);    // 
    cmpwi r16, 0; 
    beq- 5f;        // IOS58 not found. Lets return and use the normal IOS36
    
    // If we are still here, IOS58 does exist, so we can use it. 
    // we need to make sure that r24 on the stack is the IOS number, and r25 is 1. 
    
    li r3, 1; 
    stw r3, 112(r1);     	// => r25
    li r3, 58;
    stw r3, 108(r1); 		// => r24
        
	
	5:	
    // If we are here, either this isn't MKWii, or we are done. 
	// END of code
	
	// restore interrupts
	// at this point we would call OSRestoreInterrupts. that function
	// just has a couple lines, let's just include it in here, then
	// we don't have to bother about porting it to all the different regions
	lwz r3, 12(r1);
	// OSRestoreInterrupts:
	cmpwi r3, 0; 
	mfmsr r4; 
	beq 1f;
	ori r5, r4, 0x8000; 
	b 2f; 
1:	rlwinm r5, r4, 0x0, 0x11, 0xf; 
2: 	mtmsr r5; 
	//rlwinm r3, r4, 0x11, 0x1f, 0x1f; 	
		// This line is included in OSRestoreInterrupts, but that's just for
		// the return value, which we don't care about, so we can ignore it.

	// restore stack stuff:
  	lwz r0,176(r1)
	mtlr r0
	lmw r2,20(r1)
	lwz r0,8(r1)
	addi r1,r1,172
	
	// Prepare to return to game: 
	.long 0x7f04c378; 	// original instruction
	lis r15, PARAMS@ha; 
    addi r15, r15, PARAMS@l; 
	lwz r6, 4(r15); 
	mtctr r6;
	bctr;

#endif
